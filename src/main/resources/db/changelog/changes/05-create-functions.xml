<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <!-- Attribute Functions -->
    <changeSet id="05-01" author="liquibase">
        <comment>Create attribute functions</comment>
        
        <!-- Function to get attribute value for a character -->
        <sql>
            create function get_attribute_value(p_character_id integer, p_attribute_type attribute_type) returns integer
                language plpgsql
            as
            $$
            DECLARE
                v_value INTEGER;
            BEGIN
                SELECT value INTO v_value
                FROM attribute
                WHERE character_id = p_character_id AND attribute_type = p_attribute_type;

                RETURN COALESCE(v_value, 0);
            END;
            $$;

            alter function get_attribute_value(integer, attribute_type) owner to postgres;
        </sql>
    </changeSet>

    <!-- Spell Functions -->
    <changeSet id="05-02" author="liquibase">
        <comment>Create spell functions</comment>
        
        <!-- Function to calculate required action points for a spell -->
        <sql>
            create function calculate_required_ap(p_spell_id integer, p_character_id integer) returns integer
                language plpgsql
            as
            $$
            DECLARE
                v_base_cost INTEGER;
                v_scales_from VARCHAR;
                v_attribute_types TEXT[];
                v_attribute_value INTEGER;
                v_attribute_factor DOUBLE PRECISION := 0;
                v_final_cost INTEGER;
            BEGIN
                -- Get spell base cost and scales_from
                SELECT base_cost, scales_from INTO v_base_cost, v_scales_from
                FROM spell
                WHERE id = p_spell_id;

                -- Parse scales_from into array
                v_attribute_types := string_to_array(v_scales_from, ',');

                -- Calculate attribute factor
                FOR i IN 1..array_length(v_attribute_types, 1) LOOP
                    v_attribute_value := get_attribute_value(p_character_id, v_attribute_types[i]::attribute_type);
                    v_attribute_factor := v_attribute_factor + (v_attribute_value / (100 * array_length(v_attribute_types, 1)));
                END LOOP;

                -- Calculate final cost
                v_final_cost := v_base_cost * (1 - v_attribute_factor);

                -- Ensure minimum cost of 1
                RETURN GREATEST(1, v_final_cost);
            END;
            $$;

            alter function calculate_required_ap(integer, integer) owner to postgres;
        </sql>
        
        <!-- Function to calculate hit chance -->
        <sql>
            create function calculate_hit_chance(p_actor_id integer, p_target_id integer) returns double precision
                language plpgsql
            as
            $$
            DECLARE
                v_actor_dexterity INTEGER;
                v_target_dexterity INTEGER;
                v_armor_swiftness DOUBLE PRECISION;
                v_hit_chance DOUBLE PRECISION;
            BEGIN
                -- Get actor and target dexterity
                v_actor_dexterity := get_attribute_value(p_actor_id, 'DEXTERITY');
                v_target_dexterity := get_attribute_value(p_target_id, 'DEXTERITY');

                -- Get target armor swiftness
                SELECT COALESCE(a.swiftness, 0) INTO v_armor_swiftness
                FROM character c
                LEFT JOIN armor_set a ON c.armor_set_id = a.id
                WHERE c.id = p_target_id;

                -- Calculate hit chance
                v_hit_chance := 0.5 + (v_actor_dexterity / 100.0) - (v_target_dexterity / 150.0) - (v_armor_swiftness / 200.0);

                -- Ensure hit chance is between 0.1 and 0.9
                RETURN GREATEST(0.1, LEAST(0.9, v_hit_chance));
            END;
            $$;

            alter function calculate_hit_chance(integer, integer) owner to postgres;
        </sql>
        
        <!-- Function to calculate spell impact -->
        <sql>
            create function calculate_spell_impact(p_spell_id integer, p_actor_id integer, p_target_id integer) returns integer
                language plpgsql
            as
            $$
            DECLARE
                v_base_value DOUBLE PRECISION;
                v_spell_element element;
                v_spell_impact_type spell_impact_type;
                v_scales_from VARCHAR;
                v_primary_attribute attribute_type;
                v_primary_attribute_value INTEGER;
                v_weapon_damage DOUBLE PRECISION := 0;
                v_target_resistant_element element;
                v_impact DOUBLE PRECISION;
            BEGIN
                -- Get spell details
                SELECT value, spell_element, spell_impact_type, scales_from 
                INTO v_base_value, v_spell_element, v_spell_impact_type, v_scales_from
                FROM spell
                WHERE id = p_spell_id;

                -- Get primary attribute (first in scales_from list)
                v_primary_attribute := (string_to_array(v_scales_from, ','))[1]::attribute_type;

                -- Get primary attribute value
                v_primary_attribute_value := get_attribute_value(p_actor_id, v_primary_attribute);

                -- Get weapon damage if applicable
                IF v_spell_impact_type = 'DAMAGE' THEN
                    SELECT COALESCE(w.damage_multiplier, 0) INTO v_weapon_damage
                    FROM character c
                    LEFT JOIN weapon w ON c.weapon_id = w.id
                    WHERE c.id = p_actor_id;
                END IF;

                -- Calculate impact
                v_impact := v_base_value * (1 + (v_primary_attribute_value / 50.0)) + (v_weapon_damage * 0.5);

                -- Check for resistance
                SELECT a.protects_from INTO v_target_resistant_element
                FROM character c
                JOIN armor_set a ON c.armor_set_id = a.id
                WHERE c.id = p_target_id;

                IF v_target_resistant_element IS NOT NULL AND v_spell_element = v_target_resistant_element THEN
                    v_impact := v_impact * 0.7; -- Damage reduction for resistance
                END IF;

                RETURN ROUND(v_impact);
            END;
            $$;

            alter function calculate_spell_impact(integer, integer, integer) owner to postgres;
        </sql>
    </changeSet>

</databaseChangeLog>