<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.20.xsd">

    <!-- Combat Procedures -->
    <changeSet id="08-01" author="liquibase">
        <comment>Create enter_combat procedure</comment>
        <sql splitStatements="false"><![CDATA[
create procedure enter_combat(IN p_location_id integer)
    language plpgsql
as
$$
DECLARE
    v_character_record RECORD;
    v_intelligence_value INTEGER;
    v_base_ap INTEGER;
    v_new_ap INTEGER;
BEGIN
    -- Create new combat round
    INSERT INTO combat_round (round_number, location_id, is_active)
    VALUES (1, p_location_id, TRUE);

    -- Allocate AP to all characters in the location
    FOR v_character_record IN (
        SELECT c.id, c.character_class_id
        FROM character c
        WHERE c.location_id = p_location_id
    ) LOOP
        -- Get character's intelligence
        v_intelligence_value := get_attribute_value(v_character_record.id, 'INTELLIGENCE');

        -- Get base AP from class
        SELECT COALESCE(action_points_multiplier, 1) * 10 INTO v_base_ap
        FROM class
        WHERE id = v_character_record.character_class_id;

        -- Calculate new AP
        v_new_ap := v_base_ap * (1 + (v_intelligence_value / 100.0));

        -- Update character's AP
        UPDATE character
        SET action_points = v_new_ap
        WHERE id = v_character_record.id;
    END LOOP;
END;
$$;

alter procedure enter_combat(integer) owner to postgres;
        ]]></sql>
    </changeSet>

    <changeSet id="08-02" author="liquibase">
        <comment>Create end_combat_round procedure</comment>
        <sql splitStatements="false"><![CDATA[
create procedure end_combat_round(IN p_location_id integer)
    language plpgsql
as
$$
DECLARE
    v_current_round_id INTEGER;
    v_current_round_number INTEGER;
    v_combat_continues BOOLEAN;
BEGIN
    -- Get current round info
    SELECT id, round_number INTO v_current_round_id, v_current_round_number
    FROM combat_round
    WHERE location_id = p_location_id AND is_active = TRUE;

    -- Update effect durations
    UPDATE effect e
    SET rounds_left = rounds_left - 1
    FROM character c
    WHERE e.character_id = c.id AND c.location_id = p_location_id;

    -- Remove expired effects
    CALL remove_expired_effects();

    -- Check if combat continues (at least one enemy remains)
    -- This is a simplified check - in a real game, you'd check for enemies vs players
    SELECT EXISTS (
        SELECT 1 
        FROM character 
        WHERE location_id = p_location_id AND hp > 0
        HAVING COUNT(*) > 1
    ) INTO v_combat_continues;

    -- Mark current round as inactive
    UPDATE combat_round
    SET is_active = FALSE
    WHERE id = v_current_round_id;

    -- If combat continues, create new round and regenerate AP
    IF v_combat_continues THEN
        -- Create new round
        INSERT INTO combat_round (round_number, location_id, is_active)
        VALUES (v_current_round_number + 1, p_location_id, TRUE);

        -- Regenerate AP for all characters
        CALL enter_combat(p_location_id);
    END IF;
END;
$$;

alter procedure end_combat_round(integer) owner to postgres;
        ]]></sql>
    </changeSet>

</databaseChangeLog>